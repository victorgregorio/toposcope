<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TopoScope Viewer</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <style>
      html, body, #cy { height: 100%; margin: 0; padding: 0; }
      body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
      #toolbar { position: absolute; top: 8px; left: 8px; right: 8px; z-index: 10; display: flex; gap: 8px; align-items: center; background: rgba(255,255,255,0.85); backdrop-filter: blur(8px); padding: 8px 12px; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); }
      #legend { margin-left: auto; display: flex; gap: 12px; align-items: center; }
      .pill { padding: 2px 8px; border-radius: 999px; font-size: 12px; color: #222; }
      /* Pixel-perfect alignment for toolbar items */
      #toolbar button { height: 28px; padding: 6px 10px; line-height: 1; display: inline-flex; align-items: center; justify-content: center; }
      #toolbar strong { display: inline-flex; align-items: center; line-height: 1; }
      .divider { width: 1px; height: 22px; background: #90a4ae; opacity: 0.7; margin: 0 10px; align-self: center; }
      .k-system { background: #ffe0b2; }
      .k-cpu { background: #c8e6c9; }
      .k-bus { background: #bbdefb; }
      .k-pci-device { background: #d1c4e9; }
      .k-usb-device { background: #ffcdd2; }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <strong>TopoScope</strong>
      <!-- Layout controls: Radial => Cytoscape 'concentric'; Compact => 'cose'; Hierarchy => 'breadthfirst'; Fit => cy.fit() -->
      <button id="radial">Radial</button> <!-- concentric layout -->
      <button id="compact">Compact</button> <!-- cose layout -->
      <button id="hierarchy">Hierarchy</button> <!-- breadthfirst layout -->
      <span class="divider"></span>
      <button id="fit">Fit</button> <!-- fit viewport -->
      <span class="divider"></span>
      <button id="save">Save</button>
      <button id="reset">Reset</button>
      <div id="legend">
        <span class="pill k-system">System</span>
        <span class="pill k-cpu">CPU</span>
        <span class="pill k-bus">Memory</span>
        <span class="pill k-bus">Bus</span>
        <span class="pill k-pci-device">PCI</span>
        <span class="pill k-bus">Storage</span>
        <span class="pill" style="background:#00897b">NVMe</span>
        <span class="pill" style="background:#546e7a">Disk</span>
        <span class="pill" style="background:#1976d2">Net</span>
        <span class="pill k-usb-device">USB</span>
      </div>
    </div>
    <div id="cy"></div>

    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.28.1/dist/cytoscape.umd.min.js"></script>
    <script>
      async function loadGraph() {
        const res = await fetch('graph.json');
        if (!res.ok) {
          const pre = document.createElement('pre');
          pre.textContent = 'graph.json not found. Place your graph JSON next to index.html.';
          document.body.appendChild(pre);
          throw new Error('graph.json not found');
        }
        return await res.json();
      }

      function summarizeProperties(kind, props) {
        if (!props) return '';
        const pick = (keys) => keys.filter(k => props[k] !== undefined && props[k] !== '')
                                   .map(k => `${k}: ${props[k]}`);
        let lines = [];
        switch (kind) {
          case 'memory':
            lines = pick(['total_gb']);
            break;
          case 'dimm':
            lines = pick(['size_gb', 'type', 'speed']);
            break;
          case 'pci-device':
            lines = pick(['class', 'address', 'pcie_speed', 'pcie_width']);
            break;
          case 'gpu-device':
            // Include class/address as fallback when vendor tools didn't enrich
            lines = pick(['class', 'address', 'driver', 'vram_mb', 'temperature_c', 'power_w', 'pcie_speed', 'pcie_width']);
            break;
          case 'nvme-device':
            lines = pick(['model', 'size_gb', 'firmware']);
            break;
          case 'disk-device':
            lines = pick(['model', 'size', 'media', 'tran']);
            break;
          case 'net-interface':
            lines = pick(['driver', 'speed_mbps', 'mac', 'bus_info']);
            break;
          case 'usb-device':
            lines = pick(['bus', 'device', 'vendor_id', 'product_id']);
            break;
          case 'cpu':
            lines = pick(['sockets', 'cores_per_socket', 'threads_per_core']);
            break;
          case 'bus':
            lines = pick(['type']);
            break;
          default:
            lines = Object.entries(props).slice(0, 3).map(([k, v]) => `${k}: ${v}`);
        }
        return lines.slice(0, 3).join('\n');
      }

      function graphToElements(graph) {
        const elements = [];
        for (const n of graph.nodes) {
          const props = n.properties || {};
          const details = summarizeProperties(n.kind, props);
          const label = details ? `${n.label}\n${details}` : n.label;
          elements.push({ data: { id: n.id, label, kind: n.kind, properties: props } });
        }
        for (const e of graph.edges) {
          elements.push({ data: { id: e.id, source: e.source, target: e.target, label: e.label || '', kind: e.kind || '' } });
        }
        return elements;
      }

      function kindColor(kind) {
        switch (kind) {
          case 'system': return '#fb8c00';
          case 'cpu': return '#43a047';
          case 'memory': return '#6d4c41';
          case 'dimm': return '#8d6e63';
          case 'bus': return '#1e88e5';
          case 'pci-device': return '#5e35b1';
          case 'gpu-device': return '#7b1fa2';
          case 'nvme-device': return '#00897b';
          case 'disk-device': return '#546e7a';
          case 'usb-device': return '#e53935';
          default: return '#546e7a';
        }
      }

      // Tiny FNV-1a hash for a stable graph identifier
      function fnv1a(str) {
        let h = 0x811c9dc5;
        for (let i = 0; i < str.length; i++) {
          h ^= str.charCodeAt(i);
          h = (h >>> 0) * 0x01000193;
          h >>>= 0;
        }
        return (h >>> 0).toString(16);
      }

      function hashGraph(graph) {
        const ids = {
          n: (graph.nodes || []).map(n => n.id).sort(),
          e: (graph.edges || []).map(e => `${e.source}->${e.target}`).sort(),
        };
        return fnv1a(JSON.stringify(ids));
      }

      function collectPositions(cy) {
        const positions = {};
        cy.nodes().forEach(n => { positions[n.id()] = n.position(); });
        return positions;
      }

      function getSavedAll(key) {
        try { return JSON.parse(localStorage.getItem(key) || '{}') || {}; } catch { return {}; }
      }

      function setSavedAll(key, obj) {
        localStorage.setItem(key, JSON.stringify(obj || {}));
      }

      function applySavedLayout(layout, key) {
        const all = getSavedAll(key);
        const saved = all && all[layout];
        if (!saved || !saved.positions) return false;
        const positions = saved.positions || {};
        const numPos = Object.keys(positions).length;
        if (numPos === 0) return false;
        try {
          cy.layout({ name: 'preset', positions: (n) => positions[n.id()] || n.position(), fit: false }).run();
          // Always fit after restoring positions for a consistent view
          cy.fit(cy.elements(), 30);
          return true;
        } catch (e) {
          console.warn('Failed to apply saved layout', layout, e);
          return false;
        }
      }

      loadGraph().then(graph => {
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: graphToElements(graph),
          style: [
            { selector: 'node', style: {
                'label': 'data(label)',
                'text-wrap': 'wrap',
                'text-max-width': 220,
                'text-valign': 'center',
                'text-halign': 'center',
                'text-justification': 'left',
                'text-margin-y': 0,
                'color': '#263238',
                'font-size': 11,
                'min-zoomed-font-size': 8,
                'background-color': '#ffffff',
                'background-opacity': 0.98,
                'border-width': 3,
                'border-color': ele => kindColor(ele.data('kind')),
                'width': 260,
                'height': 'label',
                'padding': '12px',
                'shape': 'round-rectangle',
                'box-shadow-blur': 6,
                'box-shadow-color': 'rgba(0,0,0,0.15)'
            }},
            { selector: 'edge', style: { 'width': 2, 'line-color': '#b0bec5', 'target-arrow-color': '#b0bec5', 'target-arrow-shape': 'triangle', 'curve-style': 'bezier', 'label': 'data(label)', 'font-size': 9, 'text-background-opacity': 0.7, 'text-background-color': '#fff', 'text-background-padding': 2 }},
          ],
          layout: { name: 'cose', animate: false, padding: 30 }
        });

        const storageKey = `toposcope:view:v1:${hashGraph(graph)}`;
        let currentLayout = 'radial';

        // Try to restore saved radial layout
        const restored = applySavedLayout('radial', storageKey);
        if (!restored) {
          // Default initial layout = Cytoscape 'concentric' (radial)
          const weight = (n) => {
            const k = n.data('kind');
            if (k === 'system') return 3;
            if (k === 'bus' || k === 'memory') return 2;
            return 1;
          };
          cy.layout({
            name: 'concentric', // radial
            concentric: weight,
            levelWidth: () => 1,
            minNodeSpacing: 20,
            padding: 30,
            animate: false,
          }).run();
          cy.fit();
        }

        function saveView() {
          const payload = { positions: collectPositions(cy) };
          const all = getSavedAll(storageKey);
          all[currentLayout] = payload;
          setSavedAll(storageKey, all);
        }

        let saveTimer; const debouncedSave = () => { clearTimeout(saveTimer); saveTimer = setTimeout(saveView, 250); };
        cy.on('dragfree position', 'node', debouncedSave);
        cy.on('zoom pan', debouncedSave);

        document.getElementById('fit').onclick = () => {
          // Explicitly fit all elements with padding for consistent behavior
          cy.fit(cy.elements(), 30);
        };

        document.getElementById('compact').onclick = () => {
          currentLayout = 'compact';
          // Cytoscape 'cose' force-directed layout
          if (!applySavedLayout('compact', storageKey)) {
            cy.layout({ name: 'cose', animate: false, padding: 30 }).run();
            cy.one('layoutstop', () => cy.fit());
          }
        };

        document.getElementById('hierarchy').onclick = () => {
          currentLayout = 'hierarchy';
          // Cytoscape 'breadthfirst' hierarchical layout
          // Increase spacing and include label sizes to reduce overlap
          if (!applySavedLayout('hierarchy', storageKey)) {
            cy.layout({
              name: 'breadthfirst',
              directed: true,
              roots: ['root'],
              spacingFactor: 1.5,
              padding: 40,
              nodeDimensionsIncludeLabels: true,
              animate: false,
            }).run();
            cy.one('layoutstop', () => cy.fit());
          }
        };

        document.getElementById('radial').onclick = () => {
          currentLayout = 'radial';
          // Cytoscape 'concentric' radial layout
          if (!applySavedLayout('radial', storageKey)) {
            const weight = (n) => {
              const k = n.data('kind');
              if (k === 'system') return 3;
              if (k === 'bus' || k === 'memory') return 2;
              return 1;
            };
            cy.layout({
              name: 'concentric', // radial
              concentric: weight,
              levelWidth: () => 1,
              minNodeSpacing: 20,
              padding: 30,
              animate: false,
            }).run();
            cy.one('layoutstop', () => cy.fit());
          }
        };

        // Double-click (double-tap) zoom into a node
        let lastTapAt = 0;
        let lastTapId = null;
        const dblThresholdMs = 300;
        cy.on('tap', 'node', (evt) => {
          const now = Date.now();
          const id = evt.target.id();
          if (lastTapId === id && (now - lastTapAt) < dblThresholdMs) {
            // Tight, consistent zoom-to-node: size node+label to ~70% of viewport
            const bb = evt.target.boundingBox({ includeLabels: true });
            // 60px margin
            const vw = Math.max(1, cy.width() - 60);
            const vh = Math.max(1, cy.height() - 60);
            // 70% of viewport
            let z = Math.min(vw / bb.w, vh / bb.h) * 0.60;
            // Clamp to min/max zoom
            z = Math.min(cy.maxZoom(), Math.max(cy.minZoom(), z));
            cy.animate({ zoom: z, center: { eles: evt.target } }, { duration: 220, easing: 'ease-in-out' });
            lastTapAt = 0; lastTapId = null;
          } else {
            lastTapAt = now;
            lastTapId = id;
          }
        });

        // Double-click (double-tap) on an edge → zoom to its target node
        let lastEdgeTapAt = 0;
        let lastEdgeTapId = null;
        cy.on('tap', 'edge', (evt) => {
          const now = Date.now();
          const id = evt.target.id();
          if (lastEdgeTapId === id && (now - lastEdgeTapAt) < dblThresholdMs) {
            const target = evt.target.target() || evt.target.source();
            if (target) {
              const bb = target.boundingBox({ includeLabels: true });
              const vw = Math.max(1, cy.width() - 60);
              const vh = Math.max(1, cy.height() - 60);
              let z = Math.min(vw / bb.w, vh / bb.h) * 0.60; // match node dbl-click zoom factor
              z = Math.min(cy.maxZoom(), Math.max(cy.minZoom(), z));
              cy.animate({ zoom: z, center: { eles: target } }, { duration: 220, easing: 'ease-in-out' });
            }
            lastEdgeTapAt = 0; lastEdgeTapId = null;
          } else {
            lastEdgeTapAt = now;
            lastEdgeTapId = id;
          }
        });

        window.addEventListener('resize', () => {
          cy.resize();
          cy.fit();
        });
        document.getElementById('save').onclick = () => {
          saveView();
          // Visual feedback
          const btn = document.getElementById('save');
          const orig = btn.textContent;
          btn.textContent = 'Saved';
          setTimeout(() => { btn.textContent = orig; }, 800);
        };
        document.getElementById('reset').onclick = () => {
          localStorage.removeItem(storageKey);
          currentLayout = 'radial';
          // Reset to default radial (concentric) layout
          const weight = (n) => {
            const k = n.data('kind');
            if (k === 'system') return 3;
            if (k === 'bus' || k === 'memory') return 2;
            return 1;
          };
          cy.layout({
            name: 'concentric', // radial
            concentric: weight,
            levelWidth: () => 1,
            minNodeSpacing: 20,
            padding: 30,
            animate: false,
          }).run();
          cy.one('layoutstop', () => cy.fit());
        };
      });
    </script>
  </body>
  </html>
